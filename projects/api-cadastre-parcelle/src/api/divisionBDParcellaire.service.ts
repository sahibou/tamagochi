/**
 * Module Cadastre
 *  Le service d’interrogation du cadastre permet d’obtenir les informations suivantes:    * les limites d'une commune   * les sections parcellaires   * les parcelles cadastrales   * le centroïde d’une parcelle (localisants)  Toutes les réponses sont au format GeoJSON et de type FeatureCollection. Toutes les requêtes du module cadastre peuvent se faire en POST ou en GET.  Sur cette page, vous pouvez uniquement tester les modules avec des requêtes en GET.  Consultez la [documentation utilisateur](https://apicarto.ign.fr/api/doc/pdf/docUser_moduleCadastre.pdf) pour plus d’informations sur les paramètres d’appel disponibles et le format des résultats. ## Utilisation des ressources :      Le champ *source_ign* permet de définir la ressource utilisée par l'API :    * PCI pour le Parcellaire Express   * BDP pour la BD Parcellaire   * Si le champ n'est pas rempli c'est le PCI qui sera utilisé      La recherche des sections cadastrales se fait au travers de l'API feuille PCI Express et division BD Parcellaire selon le produit utilisé.      **Exemple de géométrie : (référentiel EPSG:4326)**    * Point:           `{\"type\": \"Point\",\"coordinates\":[-1.691634,48.104237]}`    * MultiPolygon:           `{\"type\":\"MultiPolygon\",\"coordinates\":[[[[-0.288863182067871,48.963666607295977],[-0.299592018127441,48.959299208576141],[-0.296330451965332,48.955325952385039],[-0.282125473022461,48.950675995388366],[-0.279722213745117,48.967019382922331],[-0.288863182067871,48.963666607295977]]]]}`      * Polygone trouée:             `{\"type\":\"Polygon\",\"coordinates\":[[[1.2,48.85],[1.3,48.85],[1.3,48.9],[1.2,48.9],[1.2,48.85]],[[1.23,48.86],[1.23,48.88],[1.26,48.88],[1.26,48.86],[1.23,48.86]]]}`    * Linéaire:       `{\"type\":\"LineString\",\"coordinates\":[[4.681549,47.793784],[4.741974,47.788248]]}`   **Informations importantes**     * Le produit BD Parcellaire est un produit historique qui n'est plus mis à jour. Il est donc fortement conseillé d'utiliser le produit Parcellaire Express qui bénéficie d'une mise à jour semestrielle. [Voir la documentation de comparaison des deux produits](https://geoservices.ign.fr/ressources_documentaires/Espace_documentaire/PARCELLAIRE_CADASTRAL/Parcellaire_Express_PCI/Comparatif_PEPCI_BDPARCELLAIRE.pdf).       * L'attribut *source_ign* est actuellement par défaut (valeur non remplie) interprété comme PCI.  ## Historique des changements    * Suppression /cadastre/geometrie : récupération des parcelles avec calcul de surfaces   * Uniformisation des noms d'attribut et paramètres de filtrage. Paramètre de filtrage = nom de l'attribut (codearr => code_arr, insee => code_insee, etc.)   * Ajout de la possibilité d'utiliser les couches PCI EXPRESS ou les couches BD PARCELLAIRE   * Création de la valeur BDP pour l'attribut *source_ign*   * Suppression du paramètre *apikey*   * Limitation à 500 réponses pour la recherche de communes 
 *
 * OpenAPI spec version: 2.8.7
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { FeatureCollectionDivision } from '../model/featureCollectionDivision';
import { Geometry } from '../model/geometry';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class DivisionBDParcellaireService {

    protected basePath = 'https://apicarto.ign.fr/';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Recherche d&#x27;informations sur les divisions parcellaires d&#x27;une commune
     * Retourne un résultat de Type \&quot;FeatureCollection\&quot; avec la liste des divisions parcellaires d&#x27;une commune * Paramètre insee &#x3D;&gt; Retour des divisions parcellaires d&#x27;une commune * Paramètre Insee + section &#x3D;&gt; Retour des divisions parcellaires d&#x27;une section dans une commune 
     * @param codeInsee Code insee de la commune sur 5 caractères
     * @param codeDep Code du département
     * @param codeCom Code de la commune
     * @param section Section de la parcelle sur 2 caractères
     * @param codeArr Code arrondisssement pour Paris, Lyon, Marseille
     * @param geom Géométrie au format GeoJson
     * @param limit Limite de résultats à afficher(chiffre entre 1 et 1000)
     * @param start Position pour le début de la recherche
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDivision(codeInsee?: any, codeDep?: any, codeCom?: any, section?: any, codeArr?: any, geom?: Geometry, limit?: any, start?: any, observe?: 'body', reportProgress?: boolean): Observable<FeatureCollectionDivision>;
    public getDivision(codeInsee?: any, codeDep?: any, codeCom?: any, section?: any, codeArr?: any, geom?: Geometry, limit?: any, start?: any, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeatureCollectionDivision>>;
    public getDivision(codeInsee?: any, codeDep?: any, codeCom?: any, section?: any, codeArr?: any, geom?: Geometry, limit?: any, start?: any, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeatureCollectionDivision>>;
    public getDivision(codeInsee?: any, codeDep?: any, codeCom?: any, section?: any, codeArr?: any, geom?: Geometry, limit?: any, start?: any, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {









        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (codeInsee !== undefined && codeInsee !== null) {
            queryParameters = queryParameters.set('code_insee', <any>codeInsee);
        }
        if (codeDep !== undefined && codeDep !== null) {
            queryParameters = queryParameters.set('code_dep', <any>codeDep);
        }
        if (codeCom !== undefined && codeCom !== null) {
            queryParameters = queryParameters.set('code_com', <any>codeCom);
        }
        if (section !== undefined && section !== null) {
            queryParameters = queryParameters.set('section', <any>section);
        }
        if (codeArr !== undefined && codeArr !== null) {
            queryParameters = queryParameters.set('code_arr', <any>codeArr);
        }
        if (geom !== undefined && geom !== null) {
            queryParameters = queryParameters.set('geom', <any>geom);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('_limit', <any>limit);
        }
        if (start !== undefined && start !== null) {
            queryParameters = queryParameters.set('_start', <any>start);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.request<FeatureCollectionDivision>('get',`${this.basePath}/api/cadastre/division`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
